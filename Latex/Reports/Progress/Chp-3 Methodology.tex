\chapter{Methodology and Design}
This chapter will describe the methodology used in the project. The project is mostly software based and so that will be the focus. However, there is a physical element in that of the vessel and the electrical hardware. The mechanical design and fabrication of the thruster mounts is outside the scope of this project and so it will be described only in terms of how it interfaces with the electrical hardware.\par
\section{Software Environment}
The microcontroller that was chosen for this project is a Arduino DUE. An Arduino microcontroller was chosen as there is a wide range of Arduino libraries available online, as well as several forums and code examples. Furthermore, the Arduino environment uses the C language. \par
\section{System Design}
	\subsection{Objective}
	The system needs to be designed to be deployed for long periods of time between servicing. The future addition of power regeneration such as solar or wind can be used to improve the deployable range and period of the vessel but the energy storage must be designed to handle an extended period of ‘dark time’, any time when the power regeneration is negligible. \par
	The vessel must be autonomous and having received a set of points before deployment, navigate between these points until retrieval. Even under non ideal circumstances the vessel should be able to correct its course and continue to navigate to the set points. \par
	This system is a proof of concept that is designed to be able sized up to a larger vessel. Therefore the prototype vessel should be able to handle any conditions that could be encountered in testing and all electronics should be sufficiently sealed so that no damage is incurred. It is not expected that the prototype vessel can handle rough and storm weather conditions.\par
	\subsection{Engineering Requirements}
	The prototype is a proof of concept that can be scaled up to a larger vessel and so a small vessel that can accommodate at least 2 people is required. This is preferred to a smaller vessel that cannot accommodate the weight of a person as the weight to power ratio of a small vessel would not be as representative and this could influence the steering capability of the vessel and therefore the control system.
	Furthermore, a working vessel is going to require a large battery bank and this is easily represented in a larger vessel. The energy source can then be scaled up by adding cells in both parallel and series to create the required power supply for the working vessel.\par
	The autonomous nature of the vessel means that the a electronic control system is required to control the vessel. Furthermore, there are several elements that are required to make up the system however, these are not integral to the autonomous nature of the system but integral to the system as a whole. All of these elements are listed in the table \ref{tab:3:elements} and will be further explained in the system description.\par
\section{System Description}
This section will give a broad overview of the system as a whole and describe the different sub-systems and their interactions. Several of these subsystems are outside the scope of the project but have been included to provide a foundation upon which the applicable detailed descriptions will build. \par
	\subsection{Hardware}\par
		\subsubsection{Vessel}
		The vessel is outside the scope of this project as it was acquired before the start of the project and the project was designed around the use of the vessel for testing. The vessel referred to in this project is a Spider 3, a small single hulled fibreglass boat. The vessel measures \SI{1.3}{\meter} $\times$ \SI{3.2}{\meter} and is rated to carry 4 people and a 15hp traditional outboard motor.\par
	\subsection{Electronics}\par
		\subsubsection{Arduino Due}\par
		\subsubsection{ESC}\par
		\subsubsection{PWM Signal}
		The thrusters are each controlled by a \SI{5}{\volt} PWM signal. There is limited information on the datasheet for the ESC and the signal boundaries, full forward, full reverse and neutral positions are described in the unconventional terms of the time that the signal is high. The values are shown in table \ref{tab:3:PWM}. Initially it was thought that the ESC operated at \SI{50}{\hertz}, however there was no response from the thruster at any duty cycle.\par
		\begin{table}[!ht]
			\begin{center}
				\caption{ESC boundaries and PWM duty cycle at various frequencies.}
				\label{tab:3:PWM}
				\begin{tabular}{|l|c|c|c|c|}
					\hline
					\multirow{2}{*}{Position} & \multirow{2}{*}{Time (\SI{}{\micro\second})} & \multicolumn{3}{c|}{Duty Cycle @}\\
					%\hline 
					& & \multicolumn{1}{c}{\SI{50}{\hertz}} & \multicolumn{1}{c}{\SI{60}{\hertz}} & \multicolumn{1}{c|}{\SI{500}{\hertz}}\\
					\hline
					Full Forward & 2000 & \SI{10}{\percent} & \SI{12}{\percent} & \SI{100}{\percent}  \\
					\hline
					Neutral & 1500 & \SI{7.5}{\percent} & \SI{9}{\percent} & \SI{75}{\percent}  \\
					\hline
					Full Reverse & 1000 & \SI{5}{\percent} & \SI{6}{\percent} & \SI{50}{\percent}  \\
					\hline
				\end{tabular}
			\end{center}
		\end{table}
		\vspace{0.4cm}
		In order to be sure that the correct PWM signal was being sent through and to be able to quickly vary both the frequency and the duty cycle, a PWM signal generator IC was connected to ESC and trial and error was conducted to determine that the ESC began responding to a signal above \SI{60}{\hertz}. It was then decided to push the frequency up to the maximum of \SI{500}{\hertz} as this would offers the finest control because it has the maximum allowable duty cycle difference between the signal boundaries.\par
		\vspace{0.4cm}
		The Arduino libraries contain a function that can output a PWM wave, given the duty cycle and the pin to output on as a parameter however, the default frequency of the Arduino DUE PWM pins is \SI{1000}{\hertz}. Therefore, the frequency had to be manually changed by changing the timer settings driving the PWM signal.\par
		\vspace{0.4cm}
		The information needed to change the timer settings is available in the Arduino Datasheet. The process to configure the PWM outputs is as follows. First, the peripheral clocks for timer channels 6 and 7 were enabled. Secondly, the pins input output controller on peripheral A needed to be disabled and the pins switch to peripheral type B. Then came the configuration of the timer itself. The channel mode was set to waveform mode using clock 1 with the counter being incremented on the rising edge. Furthermore, the waveform was set to UP mode (signal being set high) being triggered when the counter reached the register C (RC) value and the signal being cleared when the counter reached the register A (RA) value. Once the timer is configured, the RA and RC values can be filled and the interrupt set to trigger when the counter reaches RC. Finally, the channel control register is set to perform a software trigger, reset the counter and start the clock. There is also a interrupt handler that needs to be added where in the status register is read. This is done because the flags in the status register are automatically reset when the status register is read, at the end of every period.\par
		\vspace{0.4cm}
		The signal is being cleared when the counter reaches RA and set high when the counter reaches RC and so RC can be equated to the period of the signal and RA to the time when the signal is high. Using this and that the clock is set to clock 1 which is the MCU clock (MCK) divided by 2, the RA and RC can be expressed in terms of MCK, frequency and duty cycle as shown in equations \ref{eq:3:RC} and \ref{eq:3:RA}. RC is kept constant throughout while RA is changed to change the duty cycle of the PWM signal sent to the ESC and therefore control the ESC and thruster.
		\begin{equation}
			RC = \frac{\frac{MCK}{2}}{Frequency}
			\label{eq:3:RC}
		\end{equation}
		\begin{equation}
			RA = RC \times Duty Cycle
			\label{eq:3:RA}
		\end{equation}
		
		\subsubsection{Throttle and POT}
		The initial concept was to use two throttles that can move independently from each other and %item \ref{BOM:smallThrottle} in Appendix \ref{BOM} was
		two electronic throttles were 
		% remove comments when BOM is in place
		purchased to be used. However, when these components arrived, they were much smaller than they had appeared and they had very small range of movement. The next solution was to use two linear potentiometers (POT) and to build a throttle system that linked to the POTs. The workshop designed and built the throttle system.
		% as shown in figure \ref{fig:3:throttle}. 
		\par
		\vspace{0.4cm}
		The POT has three pins as shown in figure \ref{fig:3:POTdraw}, high voltage, ground and the output. The high voltage and ground are connected to the connections on either side and the output is connected to the middle. The output is therefore a voltage in the range of $V_{CC}$ to GND. The Arduino DUE pins are \SI{3}{\volt} tolerant and so the $V_{CC}$ is driven by \SI{3}{\volt} signal. \par
		\vspace{0.4cm}
		\begin{figure}[ht]
			\begin{center}
				\includegraphics[width = 0.3\textwidth]{figures/POT.jpg}
				\caption{Fundamental illustration of a linear potentiometer}
				\label{fig:3:POTdraw}
			\end{center}
		\end{figure}
		The output of the POT is connected to analogue pins on the MCU and so the function, \textit{analogRead()} can be used to convert the analogue voltage into digital value using the built in ADC. The ADC has a 10 bit resolution and so the digital value is an integer in the range 0 to 1024 and the smallest discernible voltage change is \SI{3}{\milli\volt}. However, the design of the throttle does not use the full \SI{300}{\degree} range and so the physical limits needed to be measured to calibrate the throttles. The measured limits and centre points for the two throttles are shown in table \ref{tab:3:POT}. The neutral position is described by two values so that there is a neutral range that could easily be achieved by the users input. \par
		%\vspace{0.4cm}
		\begin{table}[ht]
			\begin{center}
				\caption{Measured physical limits and neutral range of the throttle POTs}
				\label{tab:3:POT}
				\begin{tabular}{|l|c|c|}
					\hline		
					\textbf{Throttle Position} & \textbf{Left POT} & \textbf{Right POT} \\
					\hline
					Full Forward & 677 & 700\\
					\hline
					\multirow{2}{*}{Neutral} &530 &540 \\
					&490 &500  \\
					\hline
					Full Reverse & 321 & 340 \\
					\hline
				\end{tabular}
			\end{center}
		\end{table}
		Using table \ref{tab:3:PWM} and \ref{tab:3:POT} a relationship can be created to determine the RA value for a given throttle position. Because the forward operation is in the duty cycle range \SI{75}{\percent} to \SI{100}{\percent}, the analogue input from the POT needs to be linearly mapped to represent an equivalent duty cycle in this range. Equation \ref{eq:3:dutyF} shows how this is done for the forwards operation. The same logic can be used to determine the duty cycle for reverse as equation \ref{eq:3:dutyR} shows. However, neutral is a set value that is written to RA whenever the throttle is within the neutral range.
		\begin{equation}
			Duty Cycle_{Forward} = 100 - (100-75)(\frac{POT_{MAX} - POT_{Input}}{POT_{MAX} - POT_{Neutral}})
			\label{eq:3:dutyF}
		\end{equation}
		\begin{equation}
			Duty Cycle_{Reverse} = 75 - (75-50)(\frac{POT_{Neutral} - POT_{Input}}{POT_{Neutral} - POT_{MIN}})
			\label{eq:3:dutyR}
		\end{equation}
		\subsubsection{GPS Module}
		%Item \ref{BOM:GPS} in appendix \ref{BOM} is the GPS module used. It
		The GPS module used is a PmodGPS and it
		%remove comments when the BOM is correctly added.
		has two connectors J1, which has 6 pins and J2 which has 2 pins. J1 is used to power the GPS module as well as connect to the MCU using UART communication with a baud rate of 9600, 8 data bits, no parity and 1 stop bit. The GPS module transmits a series of 5 sentences containing various information. Each sentence begins with a '\$GP' and then the specific message ID. The data is then sent through comma separated and finally ends with a checksum and the end of line characters <CR><LF>. For this project the 'RMC' sentence is the only sentence of interest as it contains all the necessary information, longitude, latitude, speed over ground in knots and course over ground in degrees. An example of the 'RMC' sentence is shown below.\par
		\vspace{0.2cm}
		\par
		\begin{center}
			\begin{tabular}{c}
				\small{\$GPRMC,064951.000,A,2307.1256,N,12016.4438,E,0.03,165.48,260406,3.05,W,A*55<CR><LF>}\\
			\end{tabular}
		\end{center}
		\vspace{0.4cm}
		The entire sentence is read by the MCU before it starts to pick out the specific data out of the string using the commas and full stops as the guide to what array position is what data. Each piece of data is then added to an instance of a GPS structure that can then be easily parsed to the navigation algorithm and easily analysed. The variables within the GPS structure are shown in table \ref{tab:3:GPSstruct}.
		\begin{table}[!hb]
			\begin{center}
				\caption{Variables and their types within the GPS structure.}
				\label{tab:3:GPSstruct}
				\begin{tabular}{|l|l|l|}
					\hline
					\textbf{Name} & \textbf{Type} & \textbf{Description} \\
					\hline
					UTC & int & Coordinated Universal Time in the format (hhmmss). \\
					\hline
					lat & int & The whole number portion of the latitude. \\
					\hline
					latDecimal & int & The decimal portion of the latitude. \\
					\hline
					n\_s & char & A character indicating North or South. \\
					\hline
					longi & int & The whole number portion of the longitude. \\
					\hline 
					longiDecimal & int & The decimal portion of the longitude. \\
					\hline 
					e\_w & char & A character indication East or West. \\
					\hline
					knots & float & The speed over ground in knots. \\
					\hline
					course & float & The course over ground in degrees. \\
					\hline
					date & int & The date in the format (ddmmyy). \\
					\hline
				\end{tabular}
			\end{center}
		\end{table}
	\subsection{Software}

\subsection{Thrusters and Energy Cells}
The propulsion system consists of two electric thrusters mounted at the back of the vessel. These thrusters are each capable of producing up to \SI{18}{\kilogram} of thrust. They are mounted onto the back of the vessel with a metal mount that is removable and height adjustable. Each thruster has a submersible ESC attached which is controlled by a \SI{5}{\volt} PWM signal. The ESC can drive the thruster in both forward and reverse direction.\par
\vspace{0.4cm}
The thrusters are powered by a battery bank of 4 Lithium Iron Phosphate cells. Each cell has a voltage of \SI{3.3}{\volt} and a capacity of \SI{100}{\ampere\hour}. The 4 cells are connected in series to provide \SI{12}{\volt}. The battery is connected to the thrusters through a smart battery management system (BMS) which has an allowable discharge current of \SI{100}{\ampere} and an allowable charge current of \SI{50}{\ampere}.
\subsection{Control System}
The control system is the intended scope of the project and consists of a manual and automated control. For manual control, there is a two lever throttle system that is used to control the thrusters. In automated control, the control system uses a GPS and digital compass to navigate to prescribed points. At the centre of this control system is the PCB motherboard containing the MCU, GPS and connections to both the throttle and the thrusters. 
\section{Control System}
The control logic of the control system is all implemented through the software on the Arduino MCU. This section will go into detail on logic and how that logic is carried out in software as well as the electronics that are used. 
%The source code that will be discussed can be seen in Appendix \ref{Code}
